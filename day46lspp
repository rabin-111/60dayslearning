### Next.js Solution

Next.js addresses this SEO challenge by providing two powerful rendering techniques: Server-Side Rendering (SSR) and Static Site Generation (SSG).

### Server-Side Rendering (SSR)

With SSR, Next.js pre-renders the initial page on the server and sends the fully rendered HTML to the client. This means that search engine crawlers can easily index the content without having to execute JavaScript. 

### Static Site Generation (SSG)

Next.js also supports Static Site Generation (SSG), which pre-renders pages at build time and serves them as static HTML files. This approach is particularly useful for content-heavy websites or blogs, where the content doesn't change frequently. Here's an example of using SSG in Next.js:

> By leveraging SSR and SSG, Next.js provides a robust solution for SEO optimization, ensuring that your React application's content is easily discoverable and indexable by search engines like Google and Bing.
> 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/6d5fa274-c51d-4c77-b7db-a4a4d9b8262e/Untitled.png)

# Waterfalling Problem

The waterfalling problem is a common issue in traditional client-side rendered (CSR) React applications, where data fetching operations are chained or dependent on each other, leading to inefficient loading behavior. Let's understand this problem with an example of a blogging website built with React.

### Request Cycle in a Traditional React Application

Suppose you have a blogging website built with React, and a user visits the homepage. The request cycle might look something like this:

1. **Fetch the `index.html` from the CDN**: The browser first fetches the initial HTML file, which typically contains minimal content and a reference to the JavaScript bundle.
2. **Fetch the `script.js` from the CDN**: After the initial HTML is loaded, the browser fetches the JavaScript bundle, which contains the React application code.
3. **Check if the user is logged in**: Once the JavaScript bundle is loaded and executed, the application checks if the user is logged in. If the user is not logged in, they are redirected to the `/login` page.
4. **Fetch the actual blog posts**: If the user is logged in, the application fetches the actual blog post data from an API or a database.

In this scenario, there are four round trips that happen sequentially, one after the other. The browser has to wait for each step to complete before moving on to the next one, resulting in a "waterfalling" effect. This can lead to slow initial load times and a poor user experience, especially on slower network connections.

### Next.js Solution

Next.js provides several features and optimizations to address the waterfalling problem and improve the overall performance and loading behavior of your React application.

### Code Splitting and Lazy Loading

Next.js automatically performs code splitting and lazy loading for your application. This means that instead of loading the entire application bundle upfront, Next.js splits the code into smaller chunks and loads them on-demand as needed. This reduces the initial JavaScript payload and improves the initial load time.

### Server-Side Rendering (SSR) and Static Site Generation (SSG)

As discussed earlier, Next.js supports Server-Side Rendering (SSR) and Static Site Generation (SSG). With SSR, the initial page is pre-rendered on the server and sent as a fully rendered HTML page to the client. This eliminates the need for multiple round trips to fetch the initial content, improving the perceived loading speed.

With SSG, the pages are pre-rendered at build time and served as static HTML files. This approach is particularly beneficial for content-heavy websites or blogs, where the content doesn't change frequently.

### Incremental Static Regeneration (ISR)

Next.js 9.5 introduced Incremental Static Regeneration (ISR), which allows you to update static pages after they've been built, by re-rendering them in the background when new requests come in. This feature helps keep your static content up-to-date without the need for a full rebuild.

### Automatic Optimizations

Next.js automatically applies various optimizations to your application, such as:

- **Image Optimization**: Next.js optimizes images by resizing, compressing, and serving them in modern formats like WebP, reducing the overall page weight and improving load times.
- **Script Loading Optimization**: Next.js automatically optimizes the loading of JavaScript bundles, ensuring that they are loaded efficiently and in the correct order.

> By leveraging these features and optimizations, Next.js helps mitigate the waterfalling problem and provides a smoother and more efficient loading experience for your React application.
> 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/39f37d87-7873-4e85-be64-0f86e8379459/Untitled.png)

# **Other Next.js Offerings**

In addition to addressing the waterfalling problem, Next.js provides several other benefits over traditional React applications:

- **SEO Optimization**: Next.js's SSR and SSG capabilities ensure that your application's content is easily discoverable and indexable by search engines like Google and Bing.
- **API Routes**: Next.js allows you to handle API requests directly within your application, eliminating the need for a separate backend project.
- **File-based Routing**: Next.js provides a file-based routing system, making it easier to manage routes and handle navigation without the need for third-party libraries like React Router.
- **Bundle Size Optimizations**: Next.js automatically optimizes the bundle size of your application, reducing the overall page weight and improving load times.
- **Maintained by the Vercel Team**: Next.js is maintained by the Vercel team, ensuring regular updates, bug fixes, and new features.

However, it's important to note that Next.js also has some downsides:

- **Deployment Considerations**: Next.js applications can't be distributed via a CDN and always require a server running to handle server-side rendering, which can be more expensive compared to traditional static hosting.
- **Opinionated Framework**: Next.js is a highly opinionated framework, which can make it challenging to move out of it or integrate with other libraries or frameworks that don't align with its conventions.

> By leveraging the features and optimizations provided by Next.js, you can mitigate the waterfalling problem and improve the overall performance and user experience of your React application, while also benefiting from its other offerings like SEO optimization, API routes, and file-based routing.
> 

# Bootstrapping a Simple Next.js App

To bootstrap a new Next.js project with TypeScript, Tailwind CSS, and ESLint, we'll use the `create-next-app` command provided. We'll be using the App Router without the `src/` directory structure and enabling import aliases

### Creating the Project

Open your terminal and run the following command:

```bash
npx create-next-app@latest
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/3916ff8a-fd7b-4caf-8048-459b438b4adf/Untitled.png)

### File Structure

After the project is created, you'll see the following file structure:

```
my-next-app/
├── app/
│   ├── layout.tsx
│   ├── page.tsx
│   └── globals.css
├── node_modules/
├── package.json
├── package-lock.json
├── next.config.mjs
├── postcss.config.js
├── tailwind.config.js
├── .eslintrc.json
├── tsconfig.json
└── README.md

```

- `app/`: This directory contains all your code, components, layouts, routes, and APIs.
- `next.config.mjs`: This file is used for Next.js configuration.
- `tailwind.config.js`: This file is used for Tailwind CSS configuration.
- `.eslintrc.json`: This file contains the ESLint configuration.
- `tsconfig.json`: This file contains the TypeScript configuration.

### Initial Setup

Before we start building our application, let's clean up the initial files:

1. Open `app/page.tsx` and remove everything inside the `Home` component. Replace it with an empty `div`:

```tsx
export default function Home() {
  return <div></div>;
}
```

1. Open `app/globals.css` and remove the CSS styles, leaving only the Tailwind CSS imports:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

### Configuring Import Aliases

To enable import aliases in your Next.js project, you need to modify the `tsconfig.json` file. Open `tsconfig.json` and add the following configuration under the `compilerOptions` section:

```json
{
  "compilerOptions": {
    // ...
    "baseUrl": ".",
    "paths": {
      "@/*": ["./app/*"]
    }
  }
}
```

This configuration sets the base URL to the project root and maps the `@/` alias to the `app/` directory.

### Running the Development Server

To start the development server, run the following command in your terminal:

```bash
npm run dev
```

Open your browser and navigate to `http://localhost:3000`. You should see an empty page, which is expected since we removed the initial content from `app/page.tsx`.

# Routing in Next.js

In traditional React applications, routing is typically handled using a third-party library like React Router. However, Next.js takes a different approach by providing a file-based routing system out of the box.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/623f9504-2570-43fd-99fe-f2ed9cc0f4fc/Untitled.png)

Next.js has a built-in file-based router, which means that the way you structure your files and folders determines how routes are rendered. This approach is more intuitive and easier to reason about compared to defining routes programmatically.

According to the Next.js documentation (https://nextjs.org/docs/app/building-your-application/routing/defining-routes), the file structure directly maps to the URL structure. Each folder represents a route segment, and a special `page.tsx` (or `page.js`) file is used to make that route segment publicly accessible.

To illustrate this, let's create a new route for `/signup`:

1. Inside the `app` directory, create a new folder called `signup`:

```
my-next-app/
└── app/
    └── signup/
```

1. Inside the `signup` folder, create a new file called `page.tsx` and add a React component that will be rendered for the `/signup` route:

```tsx
// app/signup/page.tsx
export default function SignUp() {
  return (
    <div>
      <h1>Sign Up</h1>
      {/* Add your sign-up form or content here */}
    </div>
  );
}
```

1. Start the development server by running the following command in your terminal:

```bash
npm run dev
```

1. Once the development server is running, you can access the `/signup` route by visiting `http://localhost:3000/signup` in your browser.

You should now see the content from the `SignUp` component rendered on the `/signup` route.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/e8033b0f-70a7-4dfa-8157-87b421fdf784/Untitled.png)

By following this file-based routing system, you can easily create new routes by adding folders and files within the `app` directory. This approach makes it straightforward to manage and organize your application's routes without the need for a separate routing library.

# **Prettifying the `signin` page**

Let’s replace the signup page with a prettier one

```jsx

export default function Signin() {
    return <div className="h-screen flex justify-center flex-col">
        <div className="flex justify-center">
        <a href="#" className="block max-w-sm p-6 bg-white border border-gray-200 rounded-lg shadow hover:bg-gray-100 ">
                <div>
                    <div className="px-10">
                        <div className="text-3xl font-extrabold">
                            Sign in
                        </div>
                    </div>
                    <div className="pt-2">
                        <LabelledInput label="Username" placeholder="harkirat@gmail.com" />
                        <LabelledInput label="Password" type={"password"} placeholder="123456" />
                        <button type="button" className="mt-8 w-full text-white bg-gray-800 focus:ring-4 focus:ring-gray-300 font-medium rounded-lg text-sm px-5 py-2.5 me-2 mb-2">Sign in</button>
                    </div>
                </div>
            </a>
        </div>
    </div>
}

interface LabelledInputType {
    label: string;
    placeholder: string;
    type?: string;
}

function LabelledInput({ label, placeholder, type }: LabelledInputType) {
    return <div>
        <label className="block mb-2 text-sm text-black font-semibold pt-4">{label}</label>
        <input type={type || "text"} id="first_name" className="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5" placeholder={placeholder} required />
    </div>
}
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/ca28ddb9-dc31-49d8-aa1c-e5ce8a159d09/Untitled.png)

# Server-Side Rendering

Next.js provides server-side rendering out of the box, which means that the initial page load is rendered on the server and sent as a fully rendered HTML page to the client. This approach has several benefits, including improved SEO and better initial load performance.

To understand how SSR works in Next.js, let's follow these steps:

1. **Start the Development Server**

Run the following command in your terminal to start the Next.js development server:

```bash
npm run dev
```

1. **Visit the `/signup` Route**

Once the development server is running, open your browser and visit `http://localhost:3000/signup`. This will render the `SignIn` component that we created earlier for the `/signup` route.

1. **Inspect the HTML Response**

Right-click on the page and select "View Page Source" (or similar option depending on your browser). You should see the fully rendered HTML content of the `SignIn` component, including the form elements and the associated Tailwind CSS styles.

Here's an example of what the HTML response might look like:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/8337fb2e-ebe3-4348-88bf-5a896b921a57/Untitled.png)

Notice that the HTML response contains the fully rendered content of the `SignIn` component, including the form title, input fields, and the sign-in button. This is the result of server-side rendering.

1. **SEO Implications**

Now, when search engine crawlers like Googlebot try to scrape your page, they will receive this fully rendered HTML response, which clearly indicates that this is a sign-in page. This is a significant advantage over traditional client-side rendered React applications, where the initial HTML response would be minimal, and the crawlers would have difficulty understanding the content and purpose of the page.

> It's important to note that while SSR provides SEO benefits, it also introduces some additional complexity and overhead compared to static site generation (SSG) or client-side rendering (CSR). Next.js provides a flexible approach, allowing you to choose the rendering method that best suits your application's needs.
> 

# **Layouts**

Layouts in Next.js are a powerful feature that allow you to define shared UI components across multiple routes in your application. They provide a way to wrap child pages or nested layouts with common elements, such as headers, footers, sidebars, or any other reusable UI components.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/7a829d4e-c070-4a30-97c1-0bfc055e2269/Untitled.png)

Here's what you can do with layouts in Next.js:

1. **Define a Root Layout**:
    - The `app` directory in a Next.js application must include a root `layout.tsx` (or `layout.js`) file.
    - This root layout is responsible for defining the `<html>` and `<body>` tags, as well as any globally shared UI components.
    - It acts as the top-most layout, wrapping all other layouts and pages in your application.
2. **Create Nested Layouts**:
    - You can create nested layouts by adding `layout.tsx` files inside specific route segments (folders).
    - These nested layouts wrap the child pages or nested layouts within their respective route segments.
    - Nested layouts allow you to define UI components that are shared among a subset of routes in your application.
3. **Wrap Child Pages**:
    - Layouts wrap the child pages or nested layouts using the `children` prop.
    - The `children` prop is populated with the component of the child page or nested layout during rendering.
    - This allows you to surround the child content with your desired UI components, such as headers, footers, or sidebars.
4. **Access Route Parameters**:
    - Layouts can access dynamic route parameters through the `params` prop.
    - This prop contains an object with the dynamic route parameters from the root segment down to the current layout.
    - You can use these parameters to conditionally render UI components or fetch data based on the current route.
5. **Preserve State and Interactivity**:
    - On navigation, layouts preserve their state and remain interactive, without re-rendering.
    - This behavior is different from pages, which re-render on navigation.
    - Layouts can maintain state across route changes, providing a seamless user experience.
6. **Fetch Data**:
    - While layouts cannot use the built-in `getServerSideProps` or `getStaticProps` functions, you can fetch data on the client-side using hooks like `useEffect` or libraries like SWR.
    - This allows you to fetch data for shared UI components within your layouts.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/aa8e7f3d-5d93-4dca-8464-557219802512/Untitled.png)

> By leveraging layouts, you can create consistent and reusable UI structures across your Next.js application, reducing code duplication and improving maintainability. Layouts help you organize your application's UI in a modular and scalable way, making it easier to manage complex user interfaces.
> 

# Nested Layouts

Next.js allows you to create nested layouts for specific route segments, enabling you to define shared UI components for a subset of routes in your application. This feature is particularly useful when you need to add additional or niche shared UI components for certain routes.

To create a layout for a sub-route, you can follow these steps:

1. **Create a folder for the sub-route**: First, create a folder for the sub-route where you want to add the shared UI component. For example, if you want to add a shared UI component for all routes starting with `/signin`, create a `signin` folder inside the `app` directory.
2. **Add a `layout.tsx` file**: Inside the `signin` folder, create a new file called `layout.tsx` (or `layout.js` for JavaScript). This file will define the layout component for the `/signin` sub-route.

Here's an example of how you can create a layout for the `/signin` sub-route with a banner that says "Login now to get 20% off":

```tsx
// app/signin/layout.tsx
import React from 'react';

export default function SignInLayout({ children }: { children: React.ReactNode }) {
  return (
    <div>
      <div className="bg-yellow-200 py-2 text-center">
        <span className="font-bold">Login now to get 20% off</span>
      </div>
      {children}
    </div>
  );
}
```

In this example, the `SignInLayout` component renders a banner with the message "Login now to get 20% off" using Tailwind CSS classes. The `children` prop is where the child pages or nested layouts will be rendered.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/dd624914-6876-4b58-9694-424f7aa5e22a/3c6e6b62-0d82-4dc9-8297-ab5e119d38fc/Untitled.png)

You can also nest layouts further by creating additional folders inside the `signin` folder and adding `layout.tsx` files within those folders. This allows you to create even more specific shared UI components for nested routes.
